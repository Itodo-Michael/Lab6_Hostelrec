# Лабораторная работа №6: Система аутентификации и авторизации

## Реализация

Этот проект содержит полную реализацию системы аутентификации и авторизации согласно требованиям лабораторной работы.

## Выполненные задания

### 1. Создание базы данных
- **База данных:** SQLite (`auth_system_demo.db`)
- **Таблицы:**
  - `users` - пользователи (id, username, password_hash, role, mfa_enabled, mfa_secret, created_at)
  - `sessions` - сессии пользователей (id, user_id, token, created_at, expires_at, ip_address, user_agent, is_active)
  - `audit_log` - журнал аудита (id, user_id, action, details, ip_address, timestamp)

### 2. Модуль хэширования паролей
- **Алгоритм:** PBKDF2 с SHA256
- **Соль:** Автоматическая генерация (32 символа hex)
- **Итерации:** 100,000
- **Формат хранения:** `salt$hash`

### 3. Модуль аутентификации
- **Токены:** JWT (HS256)
- **Время жизни:** 30 минут
- **Проверка:** Сравнение хэшированных паролей
- **Логирование:** Успешные и неудачные попытки входа

### 4. Модуль авторизации
- **Модель ролей:** Иерархическая (admin > manager > user)
- **Проверка прав:** На основе JWT токена и роли пользователя
- **Методы:** `check_permission(token, required_role)`

### 5. Модуль управления сессиями
- **Создание сессии:** При успешной аутентификации
- **Активные сессии:** Получение списка активных сессий пользователя
- **Завершение сессии:** По ID сессии
- **Истечение:** Автоматическое по времени

### 6. Прототип системы
- **Интерфейс:** Консольный интерфейс
- **Команды:**
  - `login <username> <password>` - вход
  - `logout` - выход
  - `sessions` - показать сессии
  - `terminate <session_id>` - завершить сессию
  - `change_password <new_password>` - изменить пароль
  - `set_role <username> <role>` - изменить роль (admin only)
  - `check_perm <role>` - проверить права
  - `audit` - журнал аудита (admin only)
  - `exit` - выход

### 7. Дополнительные задания
- **Смена пароля:** Реализована с проверкой старого пароля
- **MFA:** Поддержка в базе данных (mfa_enabled, mfa_secret)
- **Управление ролями:** Полное управление ролями пользователей

## Разные подходы к реализации систем аутентификации и авторизации

### 1. Традиционная аутентификация (реализована в данной работе)
- **Описание:** Пользователь предоставляет логин и пароль, система проверяет их против базы данных
- **Преимущества:** Простота реализации, не требует внешних сервисов
- **Недостатки:** Пароли могут быть украдены, требуется хранение хэшей паролей

### 2. OAuth 2.0
- **Описание:** Протокол авторизации, позволяющий приложениям получать ограниченный доступ к ресурсам пользователя без передачи пароля
- **Пример реализации:** Google OAuth (добавлен в демонстрацию)
- **Поток:**
  1. Приложение перенаправляет пользователя к провайдеру (Google)
  2. Пользователь авторизуется у провайдера
  3. Провайдер возвращает авторизационный код
  4. Приложение обменивает код на токен доступа
- **Преимущества:** Безопасность (пароль не передается), удобство для пользователей
- **Недостатки:** Сложность реализации, зависимость от внешнего сервиса

### 3. OpenID Connect
- **Описание:** Протокол аутентификации поверх OAuth 2.0, предоставляющий информацию о пользователе
- **Особенности:** Возвращает ID токен с информацией о пользователе (email, имя и т.д.)
- **Использование:** Для единого входа (SSO) в нескольких приложениях

### 4. SAML (Security Assertion Markup Language)
- **Описание:** XML-based протокол для обмена аутентификационной информацией
- **Использование:** В корпоративных системах для SSO

### 5. Многофакторная аутентификация (MFA)
- **Описание:** Требует несколько форм верификации (пароль + SMS/апп/TOTP)
- **Реализация:** Поддержана в базе данных (mfa_enabled, mfa_secret)

## Использование криптографических библиотек

### Python hashlib
- **PBKDF2:** Для хэширования паролей с солью
- **SHA256:** Как базовый алгоритм хэширования
- **Использование:** `hashlib.pbkdf2_hmac('sha256', password.encode(), salt.encode(), 100000)`

### Python secrets
- **Генерация ключей:** `secrets.token_hex(32)` для секретных ключей JWT
- **Генерация соли:** `secrets.token_hex(16)` для соли паролей

### PyJWT
- **Создание токенов:** `jwt.encode(payload, secret, algorithm='HS256')`
- **Проверка токенов:** `jwt.decode(token, secret, algorithms=['HS256'])`

## Тестовая база данных

### Структура
- **users:** Информация о пользователях с ролями и настройками MFA
- **sessions:** Активные сессии пользователей с токенами
- **audit_log:** Журнал всех действий для аудита

### Тестовые данные
- 3 пользователя с разными ролями (admin, manager, user)
- Автоматическое создание при первом запуске

## Правила проверки прав доступа

### Иерархическая модель ролей
```
admin (уровень 3)
├── manager (уровень 2)
    └── user (уровень 1)
```

### Правила
- **admin:** Доступ ко всем функциям
- **manager:** Доступ к функциям manager и user
- **user:** Доступ только к базовым функциям

### Реализация проверки
```python
role_hierarchy = {'admin': 3, 'manager': 2, 'user': 1}
user_level = role_hierarchy.get(user_role, 0)
required_level = role_hierarchy.get(required_role, 999)
return user_level >= required_level
```

## Интеграция с Google OAuth

### Настройка
1. Создайте проект в Google Cloud Console
2. Включите Google+ API
3. Создайте OAuth 2.0 credentials (Client ID и Client Secret)
4. Добавьте redirect URI (для консольного приложения: `urn:ietf:wg:oauth:2.0:oob`)

### Использование в коде
- Установите `pip install requests`
- Настройте GOOGLE_CLIENT_ID и GOOGLE_CLIENT_SECRET как переменные окружения
- Используйте команду `oauth_login` в консольном интерфейсе

### Пример потока
```
> oauth_login
Открывается браузер для авторизации Google
Пользователь входит в Google аккаунт
Получается код авторизации
Обмен на токен доступа
Получение информации о пользователе
Создание/обновление пользователя в системе
```

## Запуск

```bash
python auth_lab_demo.py
```

## Тестовые пользователи

- **admin** / **admin123** (роль: admin)
- **manager** / **manager123** (роль: manager)
- **user** / **user123** (роль: user)

## Критерии оценки

✅ **Правильность реализации:** Все модули работают корректно
✅ **Качество кода:** Читаемый код с комментариями и документацией
✅ **Тестирование:** Автоматические тесты в `if __name__ == "__main__"`
✅ **Документирование:** Подробные комментарии и docstrings

## Безопасность

- Хэширование паролей с солью
- JWT токены с истечением
- Аудит всех действий
- Иерархическая модель ролей
- Защита от SQL-инъекций через параметризованные запросы